package com.hemebiotech.analytics;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;


public class AnalyticsCounter {

	

	public static void main(String[] args) throws IOException {
	// MAIN 1ER ETAPE :  LECTURE FICHIER : d√©clare un reader avec interface symptom read
	ISymptomReader reader = new ReadSymptomDataFromFile ();
	reader.GetSymptoms("/Users/alexandrecabanis/git/Project_DA_Java_EN_Come_to_the_Rescue_of_a_Java_Application/Project02Eclipse/src/com/hemebiotech/analytics/symptoms.txt");
	
	
		
	// MAIN 2EME ETAPE DECOMPTE SYMPTOME ET ORDRE ALPHABETIQUE
		
	AnalyticsCounter analyticsCounter = new AnalyticsCounter();
	
	
	// GENERER FICHIER DE SORTIE DES RESULTATS
		
		
		
		
		
		
		
		
		
		
// 1ERE CLASSE  : ReadSymptomDataFromFile: LECTURE DU FICHIER AVEC LE BON CHEMIN : LIGNE 27 A LIGNE 38
			//Read the file Symptom
				//* Creates a buffering character-input stream that uses a default-sized

		BufferedReader symptom = new BufferedReader (new FileReader("/Users/alexandrecabanis/git/Project_DA_Java_EN_Come_to_the_Rescue_of_a_Java_Application/Project02Eclipse/src/com/hemebiotech/analytics/symptoms.txt"));
		
		
			// Created a result with the symptom (key) and is occurance (value) in alphabetic ordrer with Treemap function
				// * Constructs a new, empty tree map, using the natural ordering of its keys
	  
		Map<String, Integer> symptoms = new TreeMap<>();
			
			
			String line = symptom.readLine();
			
			while (line !=null) {
				
				//System.out.println("Decompte des symptomes : " + line);
				
		
				
// 2EME CLASSE : AnalyticsCounter  : COMPTER LE NOMBRE DE SYMPTOME AVEC KEY ET VALUE : LIGNE 48 a LIGNE 58			
			//Counting the occurrences of symptoms with the key and the value of our Map function
				//* * @param key key whose presence in this map is to be tested
				
				if(symptoms.containsKey(line)) {
				//* * @param value value whose presence in this map is to be tested
				//**@return {@code true} if this map maps one or more keys to the specified value
			
					int value = symptoms.get(line);
					symptoms.put(line, value+1);
					
				}
				else symptoms.put(line, 1);
				
				line = symptom.readLine();
				
				
//3EME CLASSE: NOUVELLE CLASSE ? : FAIRE AFFICHER LES RESULTATS DANS LA CONSOLE ECLIPSE : LIGNE 65 a 67				
				}
			//Get the result of the number of symptoms in the IDE console
				//* @return the key corresponding to this entry
			for (Map.Entry<String, Integer> mapentry : symptoms.entrySet()) {
				System.out.println("le symptome est : "+mapentry.getKey()
						+ " au total de : " + mapentry.getValue());	}
			
			
			// impression results
			File fileOut = new File("Results.out");
			BufferedWriter results = new BufferedWriter(new FileWriter(fileOut));
			
			try {
					for (Map.Entry<String, Integer> mapentry : symptoms.entrySet() ) {
						results.write(mapentry.getKey() + " : " + mapentry.getValue() + System.getProperty("line.separator"));
						
						
					}
					results.close();
		
			}
			catch (Exception e) {
				e.printStackTrace();
				System.out.println("Cause : " + e.getCause());
				System.out.println("Message : " + e.getMessage());
				
			}
			
			System.out.println("The file " + fileOut + "has been created");
			System.out.println("filepath: " + fileOut.getAbsolutePath());

			

			
//4EME CLASSE ? : EXTRAIRE LES RESULTATS DANS UN FICHIER RESULT.OUT en TXT :

			
				
				
			}

	}
